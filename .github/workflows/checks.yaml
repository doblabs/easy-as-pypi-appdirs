name: Run checks

on:
  - push
    # What's the deal with pull_request vs. pull_request_target?
    # - If someone opens a PR from their fork, would this workflow
    #   run their (possibly malicious) code?
    #   https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks
  - pull_request

jobs:

  # *** TEST

  test:
    runs-on: ${{ matrix.platform }}

    # REFER: https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs
    strategy:
      fail-fast: true
      matrix:
        #platform: ['ubuntu-latest']
        #python-version: ['3.7', '3.8', '3.9', '3.10', '3.11']

        # DUNNO/2022-10-04: GitHub doesn't always spin up macOS and Windows
        # immediately ("Waiting for runner to start this task..."). And on
        # private repos, they charge more per minute than Ubuntu (not that
        # that affects free projects).
        # - Windows is also a lot slower. I see checkout alone ~45s!
        #   - Versus 1s on Ubuntu! (Ridiculously slower.)
        # - So, I dunno, don't bother with old Python on macOS and Windows.
        #   (Although if people report issues on missing Python versions,
        #    then consider enabling.)
        #   - Instead of using a platform array:
        #       platform: ['ubuntu-latest', 'macos-latest', 'windows-latest']
        #     Use matrix.include to add specific platform-Python combinations.
        include:
          - platform: 'macos-latest'
            python-version: '3.10'
              #- platform: 'windows-latest'
              #python-version: '3.10'

    # Set the default shell, required for "windows-latest".
    defaults:
      run:
        shell: bash

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Set up Python ${{ matrix.python-version }}
      id: setup-python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    # Cache the pip wheels (avoid re-downloading from PyPI), and give
    # install-poetry a boost. Shaves ~10s off step time, from 15s to 5s.
    # - Enable `virtualenvs-in-project` so local .venv/ is used and cached.
    # - With or without caches, Windows takes a longer time.
    #   - 2022-10-04: This test job took 4m. The install-poetry took 2m.
    #     With the cache ready on the next run, install-poetry took 54s.
    #     And with both caches used, the 4m job run was reduced to 1m 38s.
    #     Still a lot longer than Ubuntu, but also a decent improvement.
    # - Note the cache key: It invalidates cache whenever this Yaml changed.
    # REFER: https://www.peterbe.com/plog/install-python-poetry-github-actions-faster
    # REFER: https://github.com/snok/install-poetry/
    # REFER: https://github.com/actions/cache
    # SYNC_ME_0: The next two steps are the same for many jobs in this document.
    - name: Set pip wheels path (Ubuntu/macOS)
      run: echo "PIP_CACHE=~/.local" >> $GITHUB_ENV
      shell: bash
      if: (matrix.platform == 'ubuntu-latest') || (matrix.platform == 'macos-latest')
    - name: Set pip wheels path (Windows)
      run: echo "PIP_CACHE=~/AppData/Local/pip/cache" >> $GITHUB_ENV
      shell: bash
      if: matrix.platform == 'windows-latest'
    - name: Load cached $HOME/.local
      uses: actions/cache@v3
      with:
        path: ${{ env.PIP_CACHE }}
        key: dotlocal-${{ runner.os
          }}-${{ steps.setup-python.outputs.python-version
          }}-${{ hashFiles('.github/workflows/checks.yaml')
          }}

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        virtualenvs-create: true
        virtualenvs-in-project: true

    # Cache the virtualenv, avoid re-installing packages. Saves ~35s
    # from step time, from 35s to 0s (b/c skips step, because `if:`).
    # - The install-poetry doc says that, for ubuntu-latest and macos-latest,
    #   the path is:
    #     path: .venv
    #   But the the windows-latest example uses a different path.
    #     path: {cache-dir}/virtualenvs
    #   (Though the cached-pip-wheels example shows `path: ~/.cache`.)
    #   And they suggest caching pip wheels, not the venv (which saves
    #   downloading from PyPI, but not from installing).
    #   - REFER: https://github.com/snok/install-poetry/#running-on-windows
    # - The Peterbe article adds the Yaml hash to the key, which seems legit.
    #   The causes a cache miss if you edit this file, causing a fresh install...
    #   though maybe we don't need to be that aggressive?
    #   - REFER: https://www.peterbe.com/plog/install-python-poetry-github-actions-faster
    # - BWARE: install-poetry warns that Windows sometimes hangs on this step.
    #     https://github.com/snok/install-poetry/#caching-on-windows-runners
    #   So they recommend caching pip wheels instead of .venv.
    # SYNC_ME_1: The next two steps are the same for many jobs in this document.
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ github.job }}-${{ hashFiles('**/poetry.lock') }}-${{ hashFiles('.github/workflows/checks.yaml') }}
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root --with test

    - name: Test
      run: |

        # FIXME/2022-10-03 20:56: Where did I see coverage being run for tests?
        # - Do I care about coverage for all Python versions?
        # - Also, the README badge only shows one coverage...
        #   can you combine coverage from different version runs?
        # - I think maybe stick to the `coverage` job, below...
        #     run: make coverage-to-html
        #  python -m coverage run -m pytest tests/
        #  python -m coverage report

        make test
        # DEVs: If you need to test a specific function or class, try, e.g.,:
        #   poetry run python -m pytest -k test_function tests/

      # FIXME: I don't think we need `PLATFORM`, it was probably for tox.
      env:
        PLATFORM: ${{ matrix.platform }}

  # *** SAVVY

  # While it might be nice to isolate jobs in separate Yaml files, each
  # file is its own workflow, and each workflow appears separately under
  # the Actions workflow list, so easier to examine results if you keep
  # all jobs related to the same push or PR within the same workflow
  # (at least when possible: workflows that run after checks complete,
  #  like the coverage workflow, cannot be combined herein).

